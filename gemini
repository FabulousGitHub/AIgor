import google.generativeai as genai
import speech_recognition as sr
import pyaudio
import gtts
import ffmpeg
import os
import asyncio
import io
import ujson as json
import datetime as dt
from openai import OpenAI
from googlesearch import search
from datetime import datetime
from pydub import AudioSegment
from telebot.async_telebot import AsyncTeleBot, types
from TextToImage import getgenimg
import AInote
import timetoping
import geo
import textToSpeech
import searchmodule

with open(f'API/TOKEN.txt', 'r', encoding="utf-8") as f:
    TOKEN = f.read()
with open(f'API/GoogleDevAPI.txt', 'r', encoding="utf-8") as f:
    get_api_key = f.read()

bot = AsyncTeleBot(TOKEN)

genai.configure(api_key=get_api_key)

model = genai.GenerativeModel("gemma-3-27b-it")
modelcmd = genai.GenerativeModel("gemma-3-27b-it")
modelpdf = genai.GenerativeModel("gemini-2.0-flash")

client = OpenAI(
  api_key='yoursAPIkey',
  base_url='https://bothub.chat/api/v2/openai/v1'
)

rec = sr.Recognizer()
examplejson = ""
exampleaicmd = ""
FAQ = ""

with open(f'examples/exmq.txt', 'r', encoding="utf-8") as f:
    exampleaicmd = f.read()
with open(f'examples/exmjson.txt', 'r', encoding="utf-8") as f:
    examplejson = f.read()
with open(f'examples/FAQ.txt', 'r', encoding="utf-8") as f:
    FAQ = f.read()
with open(f'examples/mainprompt.txt', 'r', encoding="utf-8") as f:
    mainprompt = f.read()
    
btn1 = types.InlineKeyboardButton('Список заметок',callback_data='notelist')
btn2 = types.InlineKeyboardButton('Добавить заметку',callback_data='addnote')
btn3 = types.InlineKeyboardButton('Удалить заметку',callback_data='deletenote')
btn4 = types.InlineKeyboardButton('Очистить все заметки',callback_data='clearnotelist')
btnesc = types.InlineKeyboardButton('Меню',callback_data='esc')
btndel1 = types.InlineKeyboardButton('Удалить 1',callback_data='delnote1')
btndel2 = types.InlineKeyboardButton('Удалить 2',callback_data='delnote2')
btndel3 = types.InlineKeyboardButton('Удалить 3',callback_data='delnote3')
btndel4 = types.InlineKeyboardButton('Удалить 4',callback_data='delnote4')
btndel5 = types.InlineKeyboardButton('Удалить 5',callback_data='delnote5')


async def ogg2wav(fileogg):
    filewav = fileogg.replace('.ogg', '.wav')
    segment = AudioSegment.from_file(fileogg)
    segment.export(filewav,format='wav')

@bot.message_handler(commands=['start'])
async def start(message):
    tgid = str(message.chat.id)
#     msgpass = await timetoping.lastmessagetime(tgid)
#     if msgpass==True:
    t = await AInote.createuser(tgid)
    if t!=True:
        answer = f'**ИИгорь приветствует вас** _{message.chat.first_name}_'
        await bot.send_message(message.chat.id, text=answer,parse_mode='MarkdownV2')
        await bot.send_message(message.chat.id, text=FAQ,parse_mode='MarkdownV2')
    else:
        await bot.send_message(message.chat.id, text=f'Пользователь __{tgid}__  уже зарегистрирован',parse_mode='MarkdownV2')
        await bot.send_message(message.chat.id, text=FAQ,parse_mode='MarkdownV2')
#     else:
#         await bot.send_message(message.chat.id, text=f'{msgpass}')

@bot.message_handler(commands=['menu'])
async def mainmenu(message):
    tgid = str(message.chat.id)
    markup = types.InlineKeyboardMarkup(row_width=1)
    markup.add(btn1,btn2,btn3,btn4)
    await bot.send_message(message.chat.id, text="Основное меню",reply_markup=markup)


async def ClearMarkdown(text):
    special_chars = "\\[,.](){}#+-=><!"
    escaped_text = ""
    for i in range(len(text)):
        if text[i] in special_chars:
            escaped_text += '\\' + text[i]
        else:
            escaped_text += text[i]
    return escaped_text

async def notelist(message):
    markup = types.InlineKeyboardMarkup(row_width=1)
    markup.add(btn1,btn2,btn3,btn4)
    tgid = str(message.chat.id)
    t = await AInote.usernotelist(tgid)
    if t!=False:
        if len(t)>4095:
            t = t[:4095]
        await bot.send_message(message.chat.id,text=t,reply_markup=markup)
    else:
        await bot.send_message(message.chat.id,text='Список заметок пуст')
#     else:
#         await bot.send_message(message.chat.id, text=f'{msgpass}')

async def deletenote(message):
    tgid = str(message.chat.id)
    t = await AInote.usernotelist(tgid)
    if t!=False:
        markup = types.InlineKeyboardMarkup(row_width=5)
        markup.add(btndel1,btndel2,btndel3,btndel4,btndel5,btnesc)
        await bot.send_message(message.chat.id,text="Какую заметку удалить?",reply_markup=markup)
    else:
        await bot.send_message(message.chat.id,text='Список заметок пуст')

async def clearnotelist(message):
    markup = types.InlineKeyboardMarkup(row_width=1)
    markup.add(btn1,btn2,btn3,btn4)
    tgid = str(message.chat.id)
    t = await AInote.clearusernotelist(tgid)
    if t!=False:
        await bot.send_message(message.chat.id,text=t,reply_markup=markup)
    else:
        await bot.send_message(message.chat.id,text='Список заметок пуст',reply_markup=markup)

@bot.message_handler(content_types=['voice'])
async def voicercz(message):
    tgid = str(message.chat.id)
    msgpass = await timetoping.lastmessagetime(tgid)
    duration = 180
    if msgpass==True:
        file = await bot.get_file(message.voice.file_id)
        bytes = await bot.download_file(file.file_path)
        strbytes = str(bytes)
        if len(strbytes)/65536 > duration:
            await bot.send_message(message.chat.id,text='Я обрабатывую аудио до 3 минут! Обрезал ваше аудио!')
            try:
                sound = AudioSegment.from_file(io.BytesIO(bytes), format="ogg")
            except Exception as e:
                await bot.send_message(message.chat.id, f"Ошибка при обработке аудио: {e}")
            sound = sound[:duration*1000]
            with open(f'users/{tgid}/voicemsg{tgid}.ogg', 'wb') as f:
                sound.export(f, format="ogg")
        else:
            with open(f'users/{tgid}/voicemsg{tgid}.ogg', 'wb') as f:
                f.write(bytes)
        await ogg2wav(f'users/{tgid}/voicemsg{tgid}.ogg')
        with sr.AudioFile(f'users/{tgid}/voicemsg{tgid}.wav') as source:
            audio = rec.record(source)
        try:
            query = rec.recognize_google(audio_data=audio,language='ru-RU').lower()
            await bot.send_message(message.chat.id,text='Вы сказали: '+query)
            message.text = query
            await docmd(message)
        except sr.UnknownValueError:
            await bot.send_message(message.chat.id,text='Не понимаю, что вы сказали')
            await SaveContext(message, 'Не понимаю, что вы сказали')
        finally: 
            os.remove(f'users/{tgid}/voicemsg{tgid}.ogg')
            os.remove(f'users/{tgid}/voicemsg{tgid}.wav')
    else:
        await bot.send_message(message.chat.id, text=f'{msgpass}')

@bot.message_handler(content_types=['text'])
async def text(message):
    t = str(message)
    tgid = str(message.chat.id)
    msgpass = await timetoping.lastmessagetime(tgid)
    if msgpass==True:
        await docmd(message)
    else:
        await bot.send_message(message.chat.id, text=f'{msgpass}')

@bot.message_handler(content_types=['photo'])
async def handle_photo(message):
    tgid = str(message.chat.id)
    msgpass = await timetoping.lastmessagetime(tgid)
    if msgpass==True:
        file_info = await bot.get_file(message.photo[-1].file_id)
        downloaded_file = await bot.download_file(file_info.file_path)
        save_path = f'users/{tgid}/describe_{tgid}_img.jpg'
        with open(save_path, 'wb') as new_file:
            new_file.write(downloaded_file)
        await bot.send_message(tgid, text='Сейчас расскажу, что вижу...')
        myfile = genai.upload_file(save_path)
        cap = str(message.caption)
        if cap=="None":
            cap="Расскажи что видишь на изображении?"
        describe = str(await generatetext([myfile, cap]))
        describeMarkdown = await ClearMarkdown(describe)
        try:
            while len(describeMarkdown)>4095:
                await bot.send_message(tgid,text=describeMarkdown[:4094],parse_mode="MarkdownV2")
                describeMarkdown = describeMarkdown[4095:]
            await bot.send_message(tgid,text=describeMarkdown,parse_mode="MarkdownV2")
        except:
            while len(describe)>4095:
                await bot.send_message(tgid,text=describe[:4094],parse_mode="")
                describe = describe[4095:]
            await bot.send_message(tgid,text=describe,parse_mode="")
        await SaveContext(message, describe)
        os.remove(save_path)
    else:
        await bot.send_message(message.chat.id, text=f'{msgpass}')

async def genimg(message,reqst):
    tgid = str(message.chat.id)
    try:
        task0 = asyncio.create_task(getgenimg(reqst,tgid))
        await task0
        if task0.result()=="True":
            try:
                img = open(f'users/{tgid}/img.png', 'rb')
                await bot.send_photo(message.chat.id, photo=img)
                os.remove(f'users/{tgid}/img.png')
            except:
                os.remove(f'users/{tgid}/img.png')
                await bot.send_message(message.chat.id, text="Не удалось нарисовать, попробуйте еще раз...")
        else:
            task1 = asyncio.create_task(getgenimg(reqst,tgid))
            await task1
            if task1.result()=="True":
                try:
                    img = open(f'users/{tgid}/img.png', 'rb')
                    await bot.send_photo(message.chat.id, photo=img)
                    os.remove(f'users/{tgid}/img.png')
                except:
                    os.remove(f'users/{tgid}/img.png')
                    await bot.send_message(message.chat.id, text="Не удалось нарисовать, попробуйте еще раз...")
            else:
                await bot.send_message(message.chat.id, text="Не удалось нарисовать, попробуйте еще раз...")
    except:
        await bot.send_message(message.chat.id, text="Не удалось нарисовать, ошибка сервера...")

@bot.message_handler(content_types=['document'])
async def PDFdescribe(message):
    tgid = str(message.chat.id)
    msgpass = await timetoping.lastmessagetime(tgid)
    if msgpass==True:
        if message.document.mime_type == 'application/pdf':
            src = f'users/{tgid}/sample.pdf'
            try:
                file_info = await bot.get_file(message.document.file_id)
                downloaded_file = await bot.download_file(file_info.file_path)
                with open(src, 'wb') as new_file:
                    new_file.write(downloaded_file)
                sample_pdf = genai.upload_file(src)
                cap = "О чем этот документ?"
                if str(message.caption)!="None":
                    cap = message.caption
                request = str(modelpdf.generate_content([cap, sample_pdf]))
                requestMarkdown = await ClearMarkdown(request)
                try:
                    while len(requestMarkdown)>4095:
                        await bot.send_message(message.chat.id,text=requestMarkdown[:4094],parse_mode="MarkdownV2")
                        requestMarkdown = requestMarkdown[4095:]
                    await bot.send_message(message.chat.id,text=requestMarkdown,parse_mode="MarkdownV2")
                except:
                    while len(request)>4095:
                        await bot.send_message(message.chat.id,text=request[:4094],parse_mode="")
                        request = request[4095:]
                    await bot.send_message(message.chat.id,text=request,parse_mode="")
                
                await SaveContext(message, request)
                os.remove(src)
            except Exception as e:
                await bot.send_message(message.chat.id, text="Не удалось посмотреть документ, ошибка сервера:"+str(e))
                await SaveContext(message, "Не удалось посмотреть документ, ошибка сервера:"+str(e))
        else:
            await bot.send_message(message.chat.id, text="Я могу смотреть только PDF документы...")
            await SaveContext(message, "Я могу смотреть только PDF документы...")
    else:
        await bot.send_message(message.chat.id, text=f'{msgpass}')

async def GetContext(message):
    tgid = str(message.chat.id)
    newjsonpath = f'users/{tgid}/note.json'
    context = "Контекст отсутсвует"
    try:
        with open(newjsonpath, "r") as json_file:
            json_read = json_file.read()
        data = json.loads(json_read)
        if data[0]["0"]["context0"]!="":
            context = data[0]["0"]["context2"]
            context = context+data[0]["0"]["context1"]
            context = context+data[0]["0"]["context0"]
    except:
        pass
    return context

async def SaveContext(message, answer):
    tgid = str(message.chat.id)
    newjsonpath = f'users/{tgid}/note.json'
    try:
        with open(newjsonpath, "r") as json_file:
            json_read = json_file.read()
        data = json.loads(json_read)
    except:
        pass
    try:
        data[0]["0"]["context2"]=data[0]["0"]["context1"]
        data[0]["0"]["context1"]=data[0]["0"]["context0"]
        data[0]["0"]["context0"]="Пользователь - "+message.text+"\nПредыдущий ответ:"+answer+"\nВремя:"+str(dt.datetime.now()+dt.timedelta(hours=3))
        with open(newjsonpath, "w", encoding='ascii') as json_file:
            json_file.write(json.dumps(data))
    except:
        pass

async def DeleteContext(message):
    tgid = str(message.chat.id)
    newjsonpath = f'users/{tgid}/note.json'
    try:
        with open(newjsonpath, "r") as json_file:
            json_read = json_file.read()
        data = json.loads(json_read)
    except:
        pass
    try:
        data[0]["0"]["context2"]=""
        data[0]["0"]["context1"]=""
        data[0]["0"]["context0"]=""
        with open(newjsonpath, "w", encoding='ascii') as json_file:
            json_file.write(json.dumps(data))
    except:
        pass

async def generatetext(request):
    chat_completion = client.chat.completions.create(
        messages=[
            {
                'role': 'user',
                'content': f'{request}',
            }
        ],
        model='gpt-4.1-nano',)
    return chat_completion.choices[0].message.content

async def generatecmd(request):
    chat_completion = client.chat.completions.create(
        messages=[
            {
                'role': 'user',
                'content': f'{request}',
            }
        ],
        model='deepseek-r1-0528-qwen3-8b',)
    return chat_completion.choices[0].message.content
# * deepseek-r1-0528:free 
# * deepseek-r1t-chimera:free
# * deepseek-r1-0528-qwen3-8b 0.01+0.01
# * gemini-2.0-flash-001 0.07+0.3 
# * gpt-4.1-mini 0.3+1.2
# * deepseek-chat 0.2+0.2
# * gpt-4.1-nano 0.07+0.3
async def docmd(message):
    t = str(message.text)
    tgid = str(message.chat.id)
    context = await GetContext(message)
    newjsonpath = f'users/{tgid}/note.json'
    await bot.send_chat_action(message.chat.id, "typing",5)
    
    #cmd = str(modelcmd.generate_content(exampleaicmd+context+'\nЗапрос пользователя:'+t+'\nКакую команду должна выполнить программа?'))
    cmd = str(await generatecmd(exampleaicmd+context+'\nЗапрос пользователя:'+t+'\nКакую команду должна выполнить программа?'))
    #print(cmd)
    if cmd.find("gentxt")!=-1:
        request = str(await generatetext(mainprompt+'\nuser_query:'+t+"\nchat_history:"+context))
        #print(mainprompt+'\nuser_query:'+t+"\nchat_history:"+context)
        await SaveContext(message, request)
        requestMarkdown = await ClearMarkdown(request)
        #print(requestMarkdown)
        try:
            while len(requestMarkdown)>4095:
                await bot.send_message(message.chat.id,text=requestMarkdown[:4094],parse_mode="MarkdownV2")
                requestMarkdown = requestMarkdown[4095:]
            await bot.send_message(message.chat.id,text=requestMarkdown,parse_mode="MarkdownV2")
        except:
            while len(request)>4095:
                await bot.send_message(message.chat.id,text=request[:4094],parse_mode="")
                request = request[4095:]
            await bot.send_message(message.chat.id,text=request,parse_mode="")
    elif cmd.find("genimg")!=-1: 
        await SaveContext(message, "Сгенерированное изображение")
        t1 = cmd[cmd.find("("):len(cmd)-1+1]
        await bot.send_message(message.chat.id,text="Уже рисую,пожалуйста подождите...",parse_mode='')
        task = asyncio.create_task(genimg(message,t1))
        await task
    elif cmd.find("addnote")!=-1:
        t1 = t[7:]
        strjson = str(await generatetext("Текст пользователя:\n"+t1+"Время обращения:\n"+str(dt.datetime.now()+dt.timedelta(hours=3))[:-7]+examplejson))
        t = await AInote.savenote(strjson,tgid)
        #print(strjson)
        await bot.send_message(message.chat.id,text=t,parse_mode='')
    elif cmd.find("notelist")!=-1:
        await notelist(message)
    elif cmd.find("clearnotelist")!=-1:
        await clearnotelist(message)
    elif cmd.find("delnote")!=-1:
        cmd = cmd[cmd.find("delnote"):]
        cmd = cmd[8]
        t = await AInote.deleteusernote(int(cmd),tgid)
        await bot.send_message(message.chat.id,text=t,parse_mode='')
    elif cmd.find("mapfind")!=-1:
        await bot.send_message(tgid,text="Хорошо,пожалуйста подождите...",parse_mode='')
        await SaveContext(message, "Найденные координаты места")
        adr = cmd[cmd.find("mapfind")+8:len(cmd)-1]
        crd = await geo.getcoordinates(adr,tgid)
        if crd!=False:
            htn = crd[2]
            lat=crd[0]
            long = crd[1]
            if htn!="":
                await bot.send_location(tgid,latitude=lat,longitude=long)
                await bot.send_message(tgid,text=f'Город поиска: {htn}',parse_mode='')
                await SaveContext(message, f'Найденные координаты места {lat} {long} Город поиска: {htn}')
            else:
                await bot.send_location(tgid,latitude=lat,longitude=long)
                await bot.send_message(tgid,text="Город поиска не установлен, поиск может быть некорректен.",parse_mode='')
                await SaveContext(message, f'Найденные координаты места {lat} {long} Город поиска: не установлен')
        else:
            await bot.send_message(tgid,text="Не удалось найти место, возможно сервер перегружен...",parse_mode='')
            await SaveContext(message, f'Не удалось найти место, возможно сервер перегружен...')
    elif cmd.find("sethometown")!=-1:
        town = cmd[cmd.find("sethometown")+12:len(cmd)-1]
        t = await geo.sethometown(town,tgid)
        if t!=False:
            await bot.send_message(tgid,text=t,parse_mode='')
            await SaveContext(message, f'Установлен город поиска {town}')
            await SaveContext(message, f'Установлен город поиска {town}')
        else:
            await bot.send_message(tgid,text="Не получилось установить город поиска",parse_mode='')
            await SaveContext(message, "Не получилось установить город поиска")
    elif cmd.find("txttospeech")!=-1:
        await bot.send_message(tgid,text="Преобразую текст в аудио...")
        sex = 1
        if cmd.find("FEMALE")!=-1:
            sex = 0
        cmd = cmd[cmd.find("txttospeech")+12:len(cmd)-1]
        t = await textToSpeech_to_speech(cmd,sex,tgid)
        if t!=False:
            with open(t,"rb") as mp3file:
                audio = mp3file.read()
            await bot.send_audio(tgid,audio,caption=cmd)
            os.remove(t)
            await SaveContext(message, "Озвученный текст в формате mp3")
        else:
            if os.path.exists(t):
                os.remove(t)
            await bot.send_message(tgid,text="Не удалось озвучить...",parse_mode='')
            await SaveContext(message, "Не удалось озвучить...")
    elif cmd.find("RAG")!=-1:
        t1 = cmd[cmd.find("("):len(cmd)-1+1]
        RAGt = await searchmodule.gsearch(t1)
        if RAGt!="0":
            request = str(await generatetext("Ответь на запрос пользователя: "+t+f'\nУчитывая информацию из интернета: {RAGt}\n'+'История чата: '+context))
            requestMarkdown = await ClearMarkdown(request)
            try:
                while len(requestMarkdown)>4095:
                    await bot.send_message(message.chat.id,text=requestMarkdown[:4094],parse_mode="MarkdownV2")
                    requestMarkdown = requestMarkdown[4095:]
                await bot.send_message(message.chat.id,text=requestMarkdown,parse_mode="MarkdownV2")
            except:
                while len(request)>4095:
                    await bot.send_message(message.chat.id,text=request[:4094],parse_mode="")
                    request = request[4095:]
                await bot.send_message(message.chat.id,text=request,parse_mode="")
            await SaveContext(message, request)
        else:
            request = str(await generatetext("Ответь на запрос пользователя: "+t+'Если нужно используй контекст: '+context))
            await bot.send_message(message.chat.id,text=f'Не удалось найти информацию в интернете, но вот ответ:\n{request}')
            await SaveContext(message, f'Не удалось найти информацию в интернете, но вот ответ {request}')
    elif cmd.find("urldescribe")!=-1:
        link = cmd[cmd.find("(")+1:len(cmd)-1-1]
        RAGlink = await searchmodule.urldescribe(link)
        if RAGlink!="0":
            request = str(await generatetext("Ответь на запрос пользователя: "+t+f'\nУчитывая информацию из ссылки: {RAGlink}\n'+'История чата: '+context))
            requestMarkdown = await ClearMarkdown(request)
            try:
                while len(requestMarkdown)>4095:
                    await bot.send_message(message.chat.id,text=requestMarkdown[:4094],parse_mode="MarkdownV2")
                    requestMarkdown = requestMarkdown[4095:]
                await bot.send_message(message.chat.id,text=requestMarkdown,parse_mode="MarkdownV2")
            except:
                while len(request)>4095:
                    await bot.send_message(message.chat.id,text=request[:4094],parse_mode="")
                    request = request[4095:]
                await bot.send_message(message.chat.id,text=request,parse_mode="")
            await SaveContext(message, request)
        else:
            await bot.send_message(message.chat.id,text="Не удалось перейти по ссылке...")
            await SaveContext(message, "Не удалось перейти по ссылке...") 
    elif cmd.find("FAQ")!=-1:
        await bot.send_message(tgid,text=FAQ,parse_mode='MarkdownV2')
    elif cmd.find("deletecontext")!=-1:
        await DeleteContext(message)
        await bot.send_message(tgid,text="История чата удалена!",parse_mode='')
    else:
        request = str(await generatetext(mainprompt+'user_query:'+t+"\nchat_history:"+context))
        requestMarkdown = await ClearMarkdown(request)
        try:
            while len(requestMarkdown)>4095:
                await bot.send_message(message.chat.id,text=requestMarkdown[:4094],parse_mode="MarkdownV2")
                requestMarkdown = requestMarkdown[4095:]
            await bot.send_message(message.chat.id,text=requestMarkdown,parse_mode="MarkdownV2")
        except:
            while len(request)>4095:
                await bot.send_message(message.chat.id,text=request[:4094],parse_mode="")
                request = request[4095:]
            await bot.send_message(message.chat.id,text=request,parse_mode="")
        await SaveContext(message, request)
#         elif cmd.find("addnote")!=-1:
#         elif cmd.find("addnote")!=-1:
#         elif cmd.find("addnote")!=-1:

@bot.callback_query_handler(func=lambda call:True)
async def callback(call):
    if call.message:
        ##########mainMenu############
        if call.data == 'notelist':
            await notelist(call.message)
        if call.data == 'addnote':
            tgid = str(call.message.chat.id)
            msgpass = await timetoping.lastmessagetime(tgid)
            if msgpass==True:
                await bot.send_message(call.message.chat.id,text='Напишите или скажите "Заметка" в начале сообщения и текст заметки')
            else:
                await bot.send_message(call.message.chat.id, text=f'{msgpass}')
        if call.data == 'deletenote':
            await deletenote(call.message)
        if call.data == 'clearnotelist':
            await clearnotelist(call.message)
        if call.data == 'esc':
            await mainmenu(call.message)
         ##########deleteNotes############
        if str(call.data).find('delnote')!=-1:
            s = str(call.data)
            s = s[7:]
            t = await AInote.deleteusernote(int(s),str(call.from_user.id))
            await bot.send_message(call.message.chat.id,text=t)

async def on_start_up():
    try:
        task0 = asyncio.create_task(bot.infinity_polling(timeout=10,request_timeout=90))
        task2 = asyncio.create_task(timetoping.countupdate())
        task3 = asyncio.create_task(timetoping.pingusers())
        task4 = asyncio.create_task(timetoping.requestsupdate())
        await task0
        await task2
        await task3
        await task4
    except:
        print("Не удалось запустить бот")
asyncio.run(on_start_up())
